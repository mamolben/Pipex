typedef struct s_exec_info {
    char    **argv;
    char    **envp;
    int     infile;
    int     outfile;
    int     argc;
}   t_exec_info;

typedef struct s_pipex {
    int         cmd_count;
    int         **pipes;
    t_exec_info info;
}   t_pipex;



static void spawn_children(t_pipex *px)
{
    int     i;
    pid_t   pid;

    i = 0;
    while (i < px->cmd_count)
    {
        pid = fork();
        if (pid < 0)
            ft_error("Fork failed");
        if (pid == 0)
        {
            if (i == 0)
            {
                // Primer comando
                execute_first_child(
                    px->info.argv[2],
                    px->info.envp,
                    px->pipes[0],
                    px->info.infile
                );
            }
            else if (i == px->cmd_count - 1)
            {
                // Último comando
                execute_last_child(
                    px->info.argv[px->info.argc - 2],
                    px->info.envp,
                    px->pipes[i - 1],
                    px->info.outfile
                );
            }
            else
            {
                // Comando intermedio
                execute_middle_child(
                    px->info.argv[i + 2],
                    px->info.envp,
                    px->pipes[i - 1],
                    px->pipes[i]
                );
            }
        }
        i++;
    }
}



int main(int argc, char *argv[], char *envp[])
{
    t_pipex px;

    px.cmd_count = argc - 3; // o como determines el número de comandos
    px.pipes = create_pipes(px.cmd_count); // función que crea pipes (debes tenerla)
    px.info.argv = argv;
    px.info.envp = envp;
    px.info.infile = open_infile(argv[1]); // función que abre archivo de entrada
    px.info.outfile = open_outfile(argv[argc - 1]); // función que abre archivo de salida
    px.info.argc = argc;

    spawn_children(&px);

    // cierre de pipes, espera de procesos, etc.
}
static void spawn_children(t_pipex *px)

